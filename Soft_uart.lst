C51 COMPILER V9.00   SOFT_UART                                                             05/21/2015 14:38:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SOFT_UART
OBJECT MODULE PLACED IN Soft_uart.obj
COMPILER INVOKED BY: g:\Keil\C51\BIN\C51.EXE Source\Soft_uart.c INCDIR(..\电机控制) PRINT(.\Soft_uart.lst) OBJECT(Soft_u
                    -art.obj)

line level    source

   1          
   2          #include "Soft_uart.h"
   3          #include <stdio.h>
   4          #include <string.h>
   5          #include "motor.h"
   6          #include "timer.h"
   7          #include "steer.h"
   8          #include "IR.h"
   9          
  10          INT8U xdata Rbuf1[BufLong]; //FIFO接收区
  11          INT8U Rptr1,Rnum1;
  12          INT8U xdata Tbuf1[BufLong];//FIFO发送区
  13          INT8U Tptr1,Tnum1;
  14          signed char TimCnt1A,TimCnt1B; 
  15          INT8U Mtbuf1,Mrbuf1,TxdCnt1,RxdCnt1;
  16          //INT8U RxdCnt2,Rnum2,Rptr2,Mrbuf2,Rbuf2[BufLong]; //如果需要两个9600 RxD，则添加这些变量。
  17          
  18          INT16U  ReceiveNextByteToRead,SendNextByteToWrite;                     //接收数据读取指针
  19          bit  Brxd1,Srxd1;               //RxD检测电平
  20          //INT16U  ReceiveNextByteToRead2,SendNextByteToWrite2;                    //如果需要两个9600 RxD，则添加这些变量。
  21          //bit  Brxd2,Srxd2;                                                                                               //如果需要两个9600 RxD，则添加这些变量。
  22          
  23          static uint8 rs_rec_flag = 0; 
  24          static uint8 xdata rs_buffer[3]; 
  25          static uint8 rs_i; 
  26          
  27          void Recv(void)
  28          {
  29   1       
  30   1        
  31   1        if(RxdCnt1>1)      //存数据位8个
  32   1       
  33   1        {
  34   2       
  35   2          Mrbuf1>>=1;
  36   2       
  37   2          if(RxD1==1) Mrbuf1=Mrbuf1|0x80;
  38   2       
  39   2        }
  40   1       
  41   1        RxdCnt1--;
  42   1       
  43   1        if(RxdCnt1==1 /*&& RxD1==1*/) //数据接收完毕，未接收停止位。   RxdCnt1==0时，接收停止位
  44   1       
  45   1        { 
  46   2              Brxd1=Srxd1=1;   //重置接收状态等待下一个起始位。
  47   2          if(Rnum1<BufLong)           //FIFO队列未满
  48   2              {
  49   3                      Rbuf1[Rptr1]=Mrbuf1; //存储到FIFO队列
  50   3                      if(++Rptr1>BufLong-1) Rptr1=0;
  51   3                      if(++Rnum1>BufLong) Rnum1=BufLong;      //FIFO队列已满，不再允许数据添加
  52   3              }
  53   2      
  54   2        }
C51 COMPILER V9.00   SOFT_UART                                                             05/21/2015 14:38:31 PAGE 2   

  55   1       
  56   1      }
  57          
  58          void Send(void)
  59          {
  60   1       
  61   1       if(TxdCnt1!=0)  //字节发送状态机
  62   1       
  63   1       {
  64   2       
  65   2        if(TxdCnt1==11) TxD1=0;//发起始位0
  66   2       
  67   2        else if(TxdCnt1>2) //发数据位
  68   2       
  69   2         { Mtbuf1>>=1; TxD1=CY;}
  70   2       
  71   2        else  TxD1=1;     //发终止位1
  72   2       
  73   2        TxdCnt1--;
  74   2       
  75   2       }
  76   1       
  77   1       else if(Tnum1>0)  //检测FIFO队列
  78   1       
  79   1       {
  80   2       
  81   2         Tnum1--;
  82   2       
  83   2         Mtbuf1=Tbuf1[Tptr1]; //读取FIFO数据
  84   2       
  85   2         if(++Tptr1>=BufLong) Tptr1=0;
  86   2       
  87   2         TxdCnt1=11;     //启动发送状态机
  88   2       
  89   2       }
  90   1       
  91   1      }
  92          
  93          #ifdef TIMER_0
  94          void Timer_0(void) interrupt 1 using 3
  95          {
  96   1          /*调用红外与舵机*/
  97   1          if(IS_CON == 1)
  98   1          {
  99   2              Timer0_Init();
 100   2      
 101   2              if(IR_EN == 1)
 102   2              {
 103   3                  Timer_For_IR();
 104   3              }
 105   2              else
 106   2              {
 107   3                  Steering_Engine_Control();
 108   3              }
 109   2          }
 110   1          else
 111   1          {
 112   2      //      TMOD &= 0x00;
 113   2      //      AUXR &= 0X00;
 114   2      //      IP &= 0x00; //定时器0中断优先级最高
 115   2      //      TR0 = 0;
 116   2      //      ET0 = 0;
C51 COMPILER V9.00   SOFT_UART                                                             05/21/2015 14:38:31 PAGE 3   

 117   2      //      initiate_soft_uart();
 118   2          }
 119   1          
 120   1          /*调用软件串口*/
 121   1          if(RxdCnt1 == 0)  //接收起始识别
 122   1      
 123   1          {
 124   2              if(RxD1 == 0 && Brxd1 == 0 && Srxd1 == 1)     //第一个数据位间隔取4，保证读取脉冲中间
 125   2              {RxdCnt1 = 9; TimCnt1B = 0;}
 126   2              Srxd1 = Brxd1; Brxd1 = RxD1;
 127   2          }
 128   1      
 129   1      
 130   1          if(++TimCnt1B >= 3 && RxdCnt1 != 0) //数据接收，间隔为3
 131   1          {TimCnt1B = 0; Recv();}
 132   1      
 133   1          if(++TimCnt1A >= 3) //数据发送
 134   1          {TimCnt1A = 0; Send();}
 135   1      }
 136          #endif
 137          
 138          void soft_rs232_init (void)            //串口初始化  
 139          { 
 140   1        TH0=-BaudT; TL0=-BaudT; TR0=1;
 141   1       
 142   1        Rptr1=0;Rnum1=0;Tptr1=0;Tnum1=0;
 143   1        
 144   1        RxdCnt1=TxdCnt1=0;
 145   1        
 146   1              AUXR   |=   0x00;                  //Set T0x12 = 0, 12分频
 147   1          TMOD &= TMOD_AND_WORD;
 148   1          TMOD |= TMOD_TIME_MODE2;           //模式2，溢出触发中断后硬件自动将THx重装入TLx 确保定时器精度
 149   1          Brxd1=Srxd1=RxD1 = 1;                        //接收脚置成高电平  
 150   1          TxD1 = 1;                        //发射脚置成高电平  
 151   1              ReceiveNextByteToRead=SendNextByteToWrite=0;    //接收环形缓冲读取/写入指针初始化
 152   1          IP_PTx = 1;                        //置中断优先级为高  
 153   1              EA=1;                              //开启总中断
 154   1          IE_ETx = 1;                        //允许定时器中断 
 155   1              IE|=0x82; 
 156   1          TCON_ENABLE_TIMER = 1;             //启动定时器  
 157   1          
 158   1      }
 159          
 160          void initiate_soft_uart (void)               //软件串口初始化  
 161          {
 162   1          soft_rs232_init();                 //串口初始化  
 163   1      //  Timer0_Init();
 164   1          EA = 1;                            //开中断  
 165   1      }
 166          
 167          
 168          //由收转到发时，要先调用 soft_send_enable ()  
 169          void rs_send_byte(INT8U SendByte)      //发送一个字节  
 170          {
 171   1              while ( Tnum1 >= BufLong);             //等待FIFO队列有空
 172   1              Tbuf1[SendNextByteToWrite]=SendByte; 
 173   1              if(++SendNextByteToWrite>BufLong-1) SendNextByteToWrite=0;
 174   1              if(++Tnum1>BufLong) Tnum1=BufLong;      //FIFO队列已满，不再允许数据添加
 175   1      }
 176          
 177          void rs_Communication_Decode(void)
 178          {
C51 COMPILER V9.00   SOFT_UART                                                             05/21/2015 14:38:31 PAGE 4   

 179   1          if(rs_buffer[0] == '0') 
 180   1          {
 181   2              switch(rs_buffer[1]) 
 182   2              {
 183   3                  case '1':
 184   3                     MOTOR_GO_FORWARD;
 185   3                     //UART_send("FF000100FF", strlen("FF000100FF"));
 186   3                     return;
 187   3                  case '2':
 188   3                     MOTOR_GO_BACK;
 189   3                     //UART_send("FF000200FF", strlen("FF000200FF"));
 190   3                     return;
 191   3                  case '3':
 192   3                     MOTOR_GO_LEFT;
 193   3                     //UART_send("FF000200FF",strlen("FF000200FF"));
 194   3                     return;
 195   3                  case '4':
 196   3                     MOTOR_GO_RIGHT; 
 197   3                     return;
 198   3                  case '0':
 199   3                     MOTOR_GO_STOP; 
 200   3                     return;
 201   3                  default:
 202   3                     return;
 203   3              }
 204   2          }
 205   1          else if(rs_buffer[0] == '3')
 206   1          {
 207   2              IS_CON = 1;
 208   2          }
 209   1          else 
 210   1          {
 211   2              return;
 212   2          }
 213   1      }
 214          
 215          INT8U rs_receive_byte(void)      //接收一个字节  先调用soft_receive_enable()
 216          {
 217   1           
 218   1              INT8U outputByte=0;  
 219   1          while(Rnum1==0);                    //等待接收到一个字符
 220   1              outputByte=Rbuf1[ReceiveNextByteToRead];
 221   1      /*    
 222   1          UART_send("outputByte:", strlen("outputByte:"));  
 223   1          UART_send(&outputByte, strlen(&outputByte)); 
 224   1      */
 225   1          //Arduino端信息解析
 226   1          if(rs_rec_flag == 0) 
 227   1          {
 228   2              if(outputByte == 'F') 
 229   2              { 
 230   3                  rs_rec_flag = 1; 
 231   3                  rs_i = 0; 
 232   3              }
 233   2          }
 234   1          else
 235   1          {
 236   2              if(outputByte == 'F') 
 237   2              {
 238   3                  rs_rec_flag = 0; 
 239   3                  if(rs_i == 3) 
 240   3                  {
C51 COMPILER V9.00   SOFT_UART                                                             05/21/2015 14:38:31 PAGE 5   

 241   4                      rs_Communication_Decode();
 242   4                      //UART_init(); //       解决串口死机问题
 243   4                  }
 244   3                  rs_i = 0; 
 245   3              }
 246   2              else
 247   2              {
 248   3                  rs_buffer[rs_i] = outputByte; 
 249   3                  rs_i++; 
 250   3              }
 251   2          }
 252   1       
 253   1          
 254   1              if( ReceiveNextByteToRead<BufLong-1)
 255   1              {
 256   2                      ReceiveNextByteToRead++;
 257   2              }else{
 258   2                      ReceiveNextByteToRead=0;
 259   2              }
 260   1              Rnum1--;                                        //读取完毕，从FIFO队列中腾出一个字符
 261   1      
 262   1              return outputByte;
 263   1      }
 264          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    581    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     67    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
