C51 COMPILER V9.00   UART                                                                  05/20/2015 22:39:18 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.obj
COMPILER INVOKED BY: g:\Keil\C51\BIN\C51.EXE Source\uart.c INCDIR(..\电机控制) PRINT(.\uart.lst) OBJECT(uart.obj)

line level    source

   1          /*
   2          版权声明：
   3          WIFI机器人网・机器人创意工作室版权所有 www.wifi-robots.com
   4          您可以任意修改本程序，并应用于自行研发的智能小车机器人及其他电子产品上，但是禁止用于商业牟利。
   5          By WIFI机器人网・机器人创意工作室
   6          */
   7          
   8          #include "uart.h"
   9          #include <stdio.h>
  10          #include <string.h>
  11          #include "motor.h"
  12          #include "steer.h"
  13          #include "mem.h"
  14          #include "IR.h"
  15          #include "timer.h"       
  16          
  17          extern uint16 se_timer[8];
  18          uint8 xdata buffer[3];
  19          uint8 rec_flag=0;       //等于0等待接受 等于1正在接受 
  20          extern uchar IR_Type;  
  21          extern uchar IR_Num;
  22          extern uchar Cruising_Flag;
  23          
  24          
  25          void UART_init(void)
  26          {
  27   1              PCON |= 0x80;           //使能波特率倍速位SMOD
  28   1              SCON = 0x50;            //8位数据,可变波特率
  29   1              BRT = RELOAD_COUNT;             //设定独立波特率发生器重装值
  30   1              AUXR |= 0x04;           //独立波特率发生器时钟为Fosc,即1T
  31   1              AUXR |= 0x01;           //串口1选择独立波特率发生器为波特率发生器
  32   1              AUXR |= 0x10;           //启动独立波特率发生器
  33   1              ES      =   1;    //允许串口中断
  34   1          EA      =   1;    //开总中断
  35   1              TI      =   1;  
  36   1              EX0=0;
  37   1              EX1=0;
  38   1      }
  39          
  40          void UART_send_byte(uint8 byte)
  41          {
  42   1              ES     =   0;  //关串口中断
  43   1          TI     =   0;  //清零串口发送完成中断请求标志
  44   1          SBUF   =   byte;
  45   1          while(TI ==0); //等待发送完成
  46   1          TI     =   1;  //清零串口发送完成中断请求标志
  47   1          ES     =   1;  //允许串口中断
  48   1      }
  49          
  50          void UART_send(uint8 * Buffer, uint16 Length)
  51          {
*** WARNING C235 IN LINE 51 OF SOURCE\UART.C: parameter 2: different types
  52   1              while(Length != 0)
  53   1              {
  54   2                      UART_send_byte(*Buffer);
C51 COMPILER V9.00   UART                                                                  05/20/2015 22:39:18 PAGE 2   

  55   2                      Buffer++;
  56   2                      Length--;
  57   2              }
  58   1      
  59   1      }
  60          
  61          void Communication_Decode(void)  
  62          {       
  63   1              if(buffer[0]==0x00)
  64   1              {
  65   2                      switch(buffer[1])
  66   2                      {
  67   3                      case 0x01:
  68   3                                      MOTOR_GO_FORWARD;       
  69   3                                      UART_send("FF000100FF",strlen("FF000100FF")); 
  70   3                                      return; 
  71   3                              case 0x02:
  72   3                                      MOTOR_GO_BACK;          
  73   3                                      UART_send("FF000200FF",strlen("FF000200FF"));
  74   3                                      return;
  75   3                              case 0x03:
  76   3                                      MOTOR_GO_LEFT;    
  77   3                                      //UART_send("FF000200FF",strlen("FF000200FF"));
  78   3                                      return;
  79   3                          case 0x04:MOTOR_GO_RIGHT;   return;
  80   3                              case 0x00:MOTOR_GO_STOP;    return;
  81   3                              default: return;
  82   3                      }       
  83   2              }
  84   1              else if(buffer[0]==0x01)                                                        
  85   1              {
  86   2                      if(buffer[2]>180)
  87   2                              return;
  88   2                      switch(buffer[1])
  89   2                      {
  90   3                              case 0x01:se_timer[0]=buffer[2]; return;
  91   3                              case 0x02:se_timer[1]=buffer[2]; return;
  92   3                              case 0x03:se_timer[2]=buffer[2]; return;
  93   3                              case 0x04:se_timer[3]=buffer[2]; return;
  94   3                              case 0x05:se_timer[4]=buffer[2]; return;
  95   3                              case 0x06:se_timer[5]=buffer[2]; return;
  96   3                              case 0x07:se_timer[6]=buffer[2]; return;
  97   3                              case 0x08:se_timer[7]=buffer[2]; return;
  98   3                              default : return;
  99   3                      }
 100   2              }
 101   1              else if(buffer[0]==0x50)          //遥控器红外接收(学习)
 102   1              {
 103   2                      if((buffer[1]<5)&&(buffer[2]<10))
 104   2                      {
 105   3                              IR_Type = buffer[1];
 106   3                              IR_Num = buffer[2];
 107   3                              IR_Rec(); 
 108   3                      }
 109   2                      return;                   
 110   2              }
 111   1              else if(buffer[0]==0x51)          //遥控器红外发射(控制)
 112   1              {
 113   2                      if((buffer[1]<5)&&(buffer[2]<10))
 114   2                      {
 115   3                              IR_Type = buffer[1];
 116   3                              IR_Num = buffer[2];
C51 COMPILER V9.00   UART                                                                  05/20/2015 22:39:18 PAGE 3   

 117   3                              IR_Tra(); 
 118   3                      }
 119   2                      return;                   
 120   2              }
 121   1              else if(buffer[0]==0x13)//模式切换开关
 122   1              {
 123   2                  switch(buffer[1])
 124   2                      {
 125   3                        case 0x01: Cruising_Flag = 0x01; break;//跟随
 126   3                        case 0x02: Cruising_Flag = 0x02; break;//巡线
 127   3                        case 0x03: Cruising_Flag = 0x03; break;//避障
 128   3                        case 0x04: Cruising_Flag = 0x04; break;//雷达避障
 129   3                        case 0x00: Cruising_Flag = 0x00; break;//正常模式
 130   3                        default:Cruising_Flag = 0x00; break;//正常模式
 131   3                      }
 132   2              }
 133   1              else
 134   1              {
 135   2                      return;
 136   2              }
 137   1      }
 138          
 139          void UART_Interrupt_Receive(void) interrupt 4
 140          {
 141   1              static uint8 i;
 142   1      
 143   1          if(RI==1)
 144   1          {
 145   2              RI  =   0;
 146   2              if(rec_flag==0)
 147   2                      {
 148   3                              if(SBUF==0xff)
 149   3                              {
 150   4                                      rec_flag=1;     
 151   4                                      i=0;
 152   4                              }                       
 153   3                      }
 154   2                      else
 155   2                      {
 156   3                              if(SBUF==0xff)
 157   3                              {       
 158   4                                      rec_flag=0;     
 159   4                                      if(i==3)
 160   4                                      {
 161   5                                              Communication_Decode(); 
 162   5                                              UART_init(); // 解决串口死机问题
 163   5                                      }
 164   4                                      i=0;
 165   4                              }
 166   3                              else
 167   3                              {
 168   4                                      buffer[i]=SBUF;
 169   4                                      i++;
 170   4                              }
 171   3                      }               
 172   2          }
 173   1          else
 174   1          {
 175   2              TI  =  0;
 176   2          }
 177   1                      
 178   1      }
C51 COMPILER V9.00   UART                                                                  05/20/2015 22:39:18 PAGE 4   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    608    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =      3    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
