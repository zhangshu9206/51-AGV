C51 COMPILER V9.00   UART                                                                  05/17/2015 22:46:10 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.obj
COMPILER INVOKED BY: g:\Keil\C51\BIN\C51.EXE Source\uart.c BROWSE INCDIR(..\电机控制) DEBUG OBJECTEXTEND PRINT(.\uart.ls
                    -t) OBJECT(uart.obj)

line level    source

   1          /*
   2          版权声明：
   3          WIFI机器人网・机器人创意工作室版权所有 www.wifi-robots.com
   4          您可以任意修改本程序，并应用于自行研发的智能小车机器人及其他电子产品上，但是禁止用于商业牟利。
   5          By WIFI机器人网・机器人创意工作室
   6          */
   7          
   8          #include "uart.h"
   9          #include <stdio.h>
  10          #include <string.h>
  11          #include "motor.h"
  12          #include "steer.h"
  13          #include "mem.h"
  14          #include "IR.h"
  15          #include "timer.h"       
  16          
  17          extern uint16 se_timer[8];
  18          uint8 xdata buffer[3];
  19          uint8 rec_flag=0;       //等于0等待接受 等于1正在接受 
  20          extern uchar IR_Type;  
  21          extern uchar IR_Num;
  22          extern uchar Cruising_Flag;
  23          
  24          
  25          void UART_init(void)
  26          {
  27   1              PCON |= 0x80;           //使能波特率倍速位SMOD
  28   1              SCON = 0x50;            //8位数据,可变波特率
  29   1              BRT = RELOAD_COUNT;             //设定独立波特率发生器重装值
  30   1              AUXR |= 0x04;           //独立波特率发生器时钟为Fosc,即1T
  31   1              AUXR |= 0x01;           //串口1选择独立波特率发生器为波特率发生器
  32   1              AUXR |= 0x10;           //启动独立波特率发生器
  33   1              ES      =   1;    //允许串口中断
  34   1          EA      =   1;    //开总中断
  35   1              TI      =   1;  
  36   1              EX0=0;
  37   1              EX1=0;
  38   1      }
  39          
  40          void UART_send_byte(uint8 byte)
  41          {
  42   1              ES     =   0;  //关串口中断
  43   1          TI     =   0;  //清零串口发送完成中断请求标志
  44   1          SBUF   =   byte;
  45   1          while(TI ==0); //等待发送完成
  46   1          TI     =   1;  //清零串口发送完成中断请求标志
  47   1          ES     =   1;  //允许串口中断
  48   1      }
  49          
  50          void UART_send(uint8 * Buffer, uint16 Length)
  51          {
*** WARNING C235 IN LINE 51 OF SOURCE\UART.C: parameter 2: different types
  52   1              while(Length != 0)
  53   1              {
C51 COMPILER V9.00   UART                                                                  05/17/2015 22:46:10 PAGE 2   

  54   2                      UART_send_byte(*Buffer);
  55   2                      Buffer++;
  56   2                      Length--;
  57   2              }
  58   1      
  59   1      }
  60          
  61          void Communication_Decode(void)  
  62          {       
  63   1              if(buffer[0]==0x00)
  64   1              {
  65   2                      switch(buffer[1])
  66   2                      {
  67   3                      case 0x01:
  68   3                                      MOTOR_GO_FORWARD;       
  69   3                                      UART_send("FF000100FF",strlen("FF000100FF")); 
  70   3                                      return; 
  71   3                              case 0x02:
  72   3                                      MOTOR_GO_BACK;          
  73   3                                      UART_send("FF000200FF",strlen("FF000200FF"));
  74   3                                      return;
  75   3                              case 0x03:MOTOR_GO_LEFT;    return;
  76   3                          case 0x04:MOTOR_GO_RIGHT;   return;
  77   3                              case 0x00:MOTOR_GO_STOP;    return;
  78   3                              default: return;
  79   3                      }       
  80   2              }
  81   1              else if(buffer[0]==0x01)                                                        
  82   1              {
  83   2                      if(buffer[2]>180)
  84   2                              return;
  85   2                      switch(buffer[1])
  86   2                      {
  87   3                              case 0x01:se_timer[0]=buffer[2]; return;
  88   3                              case 0x02:se_timer[1]=buffer[2]; return;
  89   3                              case 0x03:se_timer[2]=buffer[2]; return;
  90   3                              case 0x04:se_timer[3]=buffer[2]; return;
  91   3                              case 0x05:se_timer[4]=buffer[2]; return;
  92   3                              case 0x06:se_timer[5]=buffer[2]; return;
  93   3                              case 0x07:se_timer[6]=buffer[2]; return;
  94   3                              case 0x08:se_timer[7]=buffer[2]; return;
  95   3                              default : return;
  96   3                      }
  97   2              }
  98   1              else if(buffer[0]==0x50)          //遥控器红外接收(学习)
  99   1              {
 100   2                      if((buffer[1]<5)&&(buffer[2]<10))
 101   2                      {
 102   3                              IR_Type = buffer[1];
 103   3                              IR_Num = buffer[2];
 104   3                              IR_Rec(); 
 105   3                      }
 106   2                      return;                   
 107   2              }
 108   1              else if(buffer[0]==0x51)          //遥控器红外发射(控制)
 109   1              {
 110   2                      if((buffer[1]<5)&&(buffer[2]<10))
 111   2                      {
 112   3                              IR_Type = buffer[1];
 113   3                              IR_Num = buffer[2];
 114   3                              IR_Tra(); 
 115   3                      }
C51 COMPILER V9.00   UART                                                                  05/17/2015 22:46:10 PAGE 3   

 116   2                      return;                   
 117   2              }
 118   1              else if(buffer[0]==0x13)//模式切换开关
 119   1              {
 120   2                  switch(buffer[1])
 121   2                      {
 122   3                        case 0x01: Cruising_Flag = 0x01; break;//跟随
 123   3                        case 0x02: Cruising_Flag = 0x02; break;//巡线
 124   3                        case 0x03: Cruising_Flag = 0x03; break;//避障
 125   3                        case 0x04: Cruising_Flag = 0x04; break;//雷达避障
 126   3                        case 0x00: Cruising_Flag = 0x00; break;//正常模式
 127   3                        default:Cruising_Flag = 0x00; break;//正常模式
 128   3                      }
 129   2              }
 130   1              else
 131   1              {
 132   2                      return;
 133   2              }
 134   1      }
 135          
 136          void UART_Interrupt_Receive(void) interrupt 4
 137          {
 138   1              static uint8 i;
 139   1      
 140   1          if(RI==1)
 141   1          {
 142   2              RI  =   0;
 143   2              if(rec_flag==0)
 144   2                      {
 145   3                              if(SBUF==0xff)
 146   3                              {
 147   4                                      rec_flag=1;     
 148   4                                      i=0;
 149   4                              }                       
 150   3                      }
 151   2                      else
 152   2                      {
 153   3                              if(SBUF==0xff)
 154   3                              {       
 155   4                                      rec_flag=0;     
 156   4                                      if(i==3)
 157   4                                      {
 158   5                                              Communication_Decode(); 
 159   5                                              UART_init(); // 解决串口死机问题
 160   5                                      }
 161   4                                      i=0;
 162   4                              }
 163   3                              else
 164   3                              {
 165   4                                      buffer[i]=SBUF;
 166   4                                      i++;
 167   4                              }
 168   3                      }               
 169   2          }
 170   1          else
 171   1          {
 172   2              TI  =  0;
 173   2          }
 174   1                      
 175   1      }


C51 COMPILER V9.00   UART                                                                  05/17/2015 22:46:10 PAGE 4   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    608    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =      3    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
