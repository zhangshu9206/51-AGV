C51 COMPILER V9.00   UART                                                                  05/21/2015 14:38:30 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.obj
COMPILER INVOKED BY: g:\Keil\C51\BIN\C51.EXE Source\uart.c INCDIR(..\电机控制) PRINT(.\uart.lst) OBJECT(uart.obj)

line level    source

   1          /*
   2          版权声明：
   3          WIFI机器人网・机器人创意工作室版权所有 www.wifi-robots.com
   4          您可以任意修改本程序，并应用于自行研发的智能小车机器人及其他电子产品上，但是禁止用于商业牟利。
   5          By WIFI机器人网・机器人创意工作室
   6          */
   7          
   8          #include "uart.h"
   9          #include <stdio.h>
  10          #include <string.h>
  11          #include "motor.h"
  12          #include "steer.h"
  13          #include "mem.h"
  14          #include "IR.h"
  15          #include "timer.h"       
  16          
  17          extern uint16 se_timer[8];
  18          uint8 xdata buffer[3];
  19          uint8 rec_flag=0;       //等于0等待接受 等于1正在接受 
  20          extern uchar IR_Type;  
  21          extern uchar IR_Num;
  22          extern uchar Cruising_Flag; 
  23          
  24          void UART_init(void)
  25          {
  26   1              PCON |= 0x80;           //使能波特率倍速位SMOD
  27   1              SCON = 0x50;            //8位数据,可变波特率
  28   1              BRT = RELOAD_COUNT;             //设定独立波特率发生器重装值
  29   1              AUXR |= 0x04;           //独立波特率发生器时钟为Fosc,即1T
  30   1              AUXR |= 0x01;           //串口1选择独立波特率发生器为波特率发生器
  31   1              AUXR |= 0x10;           //启动独立波特率发生器
  32   1              ES      =   1;    //允许串口中断
  33   1          EA      =   1;    //开总中断
  34   1              TI      =   1;  
  35   1              EX0=0;
  36   1              EX1=0;
  37   1      }
  38          
  39          void UART_send_byte(uint8 byte)
  40          {
  41   1              ES     =   0;  //关串口中断
  42   1          TI     =   0;  //清零串口发送完成中断请求标志
  43   1          SBUF   =   byte;
  44   1          while(TI ==0); //等待发送完成
  45   1          TI     =   1;  //清零串口发送完成中断请求标志
  46   1          ES     =   1;  //允许串口中断
  47   1      }
  48          
  49          void UART_send(uint8 * Buffer, uint16 Length)
  50          {
*** WARNING C235 IN LINE 50 OF SOURCE\UART.C: parameter 2: different types
  51   1              while(Length != 0)
  52   1              {
  53   2                      UART_send_byte(*Buffer);
  54   2                      Buffer++;
C51 COMPILER V9.00   UART                                                                  05/21/2015 14:38:30 PAGE 2   

  55   2                      Length--;
  56   2              }
  57   1      
  58   1      }
  59          
  60          void Communication_Decode(void)  
  61          {       
  62   1              if(buffer[0]==0x00)
  63   1              {
  64   2                      switch(buffer[1])
  65   2                      {
  66   3                      case 0x01:
  67   3                                      MOTOR_GO_FORWARD;       
  68   3                                      UART_send("FF000100FF",strlen("FF000100FF")); 
  69   3                                      return; 
  70   3                              case 0x02:
  71   3                                      MOTOR_GO_BACK;          
  72   3                                      UART_send("FF000200FF",strlen("FF000200FF"));
  73   3                                      return;
  74   3                              case 0x03:
  75   3                                      MOTOR_GO_LEFT;    
  76   3                                      //UART_send("FF000200FF",strlen("FF000200FF"));
  77   3                                      return;
  78   3                          case 0x04:MOTOR_GO_RIGHT;   return;
  79   3                              case 0x00:MOTOR_GO_STOP;    return;
  80   3                              default: return;
  81   3                      }       
  82   2              }
  83   1              else if(buffer[0]==0x01)                                                        
  84   1              {
  85   2                      if(buffer[2]>180)
  86   2                              return;
  87   2                      switch(buffer[1])
  88   2                      {
  89   3                              case 0x01:se_timer[0]=buffer[2]; return;
  90   3                              case 0x02:se_timer[1]=buffer[2]; return;
  91   3                              case 0x03:se_timer[2]=buffer[2]; return;
  92   3                              case 0x04:se_timer[3]=buffer[2]; return;
  93   3                              case 0x05:se_timer[4]=buffer[2]; return;
  94   3                              case 0x06:se_timer[5]=buffer[2]; return;
  95   3                              case 0x07:se_timer[6]=buffer[2]; return;
  96   3                              case 0x08:se_timer[7]=buffer[2]; return;
  97   3                              default : return;
  98   3                      }
  99   2              }
 100   1              else if(buffer[0]==0x50)          //遥控器红外接收(学习)
 101   1              {
 102   2                      if((buffer[1]<5)&&(buffer[2]<10))
 103   2                      {
 104   3                              IR_Type = buffer[1];
 105   3                              IR_Num = buffer[2];
 106   3                              IR_Rec(); 
 107   3                      }
 108   2                      return;                   
 109   2              }
 110   1              else if(buffer[0]==0x51)          //遥控器红外发射(控制)
 111   1              {
 112   2                      if((buffer[1]<5)&&(buffer[2]<10))
 113   2                      {
 114   3                              IR_Type = buffer[1];
 115   3                              IR_Num = buffer[2];
 116   3                              IR_Tra(); 
C51 COMPILER V9.00   UART                                                                  05/21/2015 14:38:30 PAGE 3   

 117   3                      }
 118   2                      return;                   
 119   2              }
 120   1              else if(buffer[0]==0x13)//模式切换开关
 121   1              {
 122   2                  switch(buffer[1])
 123   2                      {
 124   3                        case 0x01: Cruising_Flag = 0x01; break;//跟随
 125   3                        case 0x02: Cruising_Flag = 0x02; break;//巡线
 126   3                        case 0x03: Cruising_Flag = 0x03; break;//避障
 127   3                        case 0x04: Cruising_Flag = 0x04; break;//雷达避障
 128   3                 case 0x00: 
 129   3                     {
 130   4                        Cruising_Flag = 0x00; 
 131   4                        if(buffer[2] == 0x00)
 132   4                        {
 133   5                            IS_CON = 1;
 134   5                            UART_send("IS_CON1", strlen("IS_CON1")); 
 135   5                            break; //正常模式
 136   5                        }
 137   4                        else if(buffer[2] == 0x01)
 138   4                        {
 139   5                            IS_CON = 0;
 140   5                            UART_send("IS_CON0", strlen("IS_CON0")); 
 141   5                            
 142   5                            TMOD &= 0x00;
 143   5                            AUXR &= 0X00;
 144   5                            IP &= 0x00; //定时器0中断优先级最高
 145   5                            TR0 = 0;
 146   5                            ET0 = 0;
 147   5                            initiate_soft_uart();
*** WARNING C206 IN LINE 147 OF SOURCE\UART.C: 'initiate_soft_uart': missing function-prototype
 148   5                            break; //正常模式
 149   5                        }
 150   4                        else
 151   4                        ;
 152   4                        break; 
 153   4                     }
 154   3                   
 155   3                        default:Cruising_Flag = 0x00; break;//正常模式
 156   3                      }
 157   2              }
 158   1              else
 159   1              {
 160   2                      return;
 161   2              }
 162   1      }
 163          
 164          void UART_Interrupt_Receive(void) interrupt 4
 165          {
 166   1              static uint8 i;
 167   1      
 168   1          if(RI==1)
 169   1          {
 170   2              RI  =   0;
 171   2              if(rec_flag==0)
 172   2                      {
 173   3                              if(SBUF==0xff)
 174   3                              {
 175   4                                      rec_flag=1;     
 176   4                                      i=0;
 177   4                              }                       
C51 COMPILER V9.00   UART                                                                  05/21/2015 14:38:30 PAGE 4   

 178   3                      }
 179   2                      else
 180   2                      {
 181   3                              if(SBUF==0xff)
 182   3                              {       
 183   4                                      rec_flag=0;     
 184   4                                      if(i==3)
 185   4                                      {
 186   5                                              Communication_Decode(); 
 187   5                                              UART_init(); // 解决串口死机问题
 188   5                                      }
 189   4                                      i=0;
 190   4                              }
 191   3                              else
 192   3                              {
 193   4                                      buffer[i]=SBUF;
 194   4                                      i++;
 195   4                              }
 196   3                      }               
 197   2          }
 198   1          else
 199   1          {
 200   2              TI  =  0;
 201   2          }
 202   1                      
 203   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    701    ----
   CONSTANT SIZE    =     38    ----
   XDATA SIZE       =      3    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
